name: Create Community Contribution Issue

on:
  schedule:
    - cron: '*/20 * * * *'
  workflow_dispatch:
    inputs:
      force_type:
        description: 'Force issue type: theme | fact | proverb | trivia | grammar | animeQuote'
        required: false
        type: string
      dry_run:
        description: 'Do not create an issue; only log selection'
        required: false
        type: boolean

permissions:
  contents: read
  issues: write

# Prevent multiple runs from overlapping and causing race conditions
concurrency:
  group: community-issue-creation
  cancel-in-progress: true

jobs:
  create-issue:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: github.repository == 'lingdojo/kana-dojo'
    env:
      AUTOMATION_PR_TOKEN: ${{ secrets.AUTOMATION_PR_TOKEN }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          persist-credentials: false

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Create community issue
        id: create-issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const templates = require('./.github/templates/messages.cjs');
            const t = templates.issueCreation;

            const forceType = (context.payload.inputs && context.payload.inputs.force_type) ? String(context.payload.inputs.force_type).trim() : '';
            const dryRun = !!(context.payload.inputs && (context.payload.inputs.dry_run === true || context.payload.inputs.dry_run === 'true'));

            const emojiBank = [
              'üé®', 'üéã', 'üéå', 'üå∏', 'üåä', 'üåô', '‚≠ê', 'üçú', 'üçô', 'üçµ',
              'üß≠', 'üß©', 'ü™Ñ', 'ü™∑', 'ü™≠', 'üéè', 'üèÆ', 'üóæ', '‚õ©Ô∏è', 'üóª',
              'üåßÔ∏è', '‚ö°', '‚ùÑÔ∏è', 'üçÇ', 'üç£', 'üç°', 'ü•¢', 'üßß', 'üìö', 'üñåÔ∏è',
              'üßµ', 'üéé', 'ü™ô', 'üõ§Ô∏è', 'üöÖ', 'üß™', 'üß†', 'üß∂', 'ü™ü', 'ü™®',
              'üèØ', 'üèπ', 'ü™Å', 'üêâ', 'ü¶ä', 'üêæ', 'üêº', 'ü¶ã', 'üêü', 'ü™∏'
            ];

            function pickEmoji() {
              return emojiBank[Math.floor(Math.random() * emojiBank.length)];
            }

            const statePath = 'data/community/automation-state.json';
            const themeBacklogPath = 'data/community/theme-backlog.json';
            const factsBacklogPath = 'data/community/facts-backlog.json';
            const proverbsBacklogPath = 'data/community/proverbs-backlog.json';
            const triviaBacklogPath = 'data/community/trivia-backlog.json';
            const grammarBacklogPath = 'data/community/grammar-backlog.json';
            const animeQuotesBacklogPath = 'data/community/anime-quotes-backlog.json';

            const themesSourcePath = 'features/Preferences/data/themes.ts';
            const factsSourcePath = 'public/japan-facts.json';
            const proverbsSourcePath = 'public/japanese-proverbs.json';
            const triviaSourcePaths = {
              easy: 'public/japan-trivia-easy.json',
              medium: 'public/japan-trivia-medium.json',
              hard: 'public/japan-trivia-hard.json'
            };
            const triviaLegacyPath = 'public/japan-trivia.json';
            const grammarSourcePath = 'public/japanese-grammar.json';
            const animeQuotesSourcePath = 'public/anime-quotes.json';

            let state = JSON.parse(fs.readFileSync(statePath, 'utf8'));
            const themes = JSON.parse(fs.readFileSync(themeBacklogPath, 'utf8'));
            const facts = JSON.parse(fs.readFileSync(factsBacklogPath, 'utf8'));
            const proverbs = JSON.parse(fs.readFileSync(proverbsBacklogPath, 'utf8'));
            const trivia = JSON.parse(fs.readFileSync(triviaBacklogPath, 'utf8'));
            const grammar = JSON.parse(fs.readFileSync(grammarBacklogPath, 'utf8'));
            const animeQuotes = JSON.parse(fs.readFileSync(animeQuotesBacklogPath, 'utf8'));

            if (typeof state.consecutiveNoIssueRuns !== 'number') {
              state.consecutiveNoIssueRuns = 0;
            }

            let backlogChanged = false;

            let existingFacts = [];
            if (fs.existsSync(factsSourcePath)) {
              try {
                existingFacts = JSON.parse(fs.readFileSync(factsSourcePath, 'utf8'));
              } catch (e) {
                console.log(`Could not parse ${factsSourcePath}: ${e.message}`);
              }
            }

            let existingProverbs = [];
            if (fs.existsSync(proverbsSourcePath)) {
              try {
                existingProverbs = JSON.parse(fs.readFileSync(proverbsSourcePath, 'utf8'));
              } catch (e) {
                console.log(`Could not parse ${proverbsSourcePath}: ${e.message}`);
              }
            }

            let existingTrivia = [];
            const triviaSourceFiles = [
              ...Object.values(triviaSourcePaths),
              triviaLegacyPath
            ];
            triviaSourceFiles.forEach(function(path) {
              if (fs.existsSync(path)) {
                try {
                  const data = JSON.parse(fs.readFileSync(path, 'utf8'));
                  if (Array.isArray(data)) {
                    existingTrivia = existingTrivia.concat(data);
                  }
                } catch (e) {
                  console.log(`Could not parse ${path}: ${e.message}`);
                }
              }
            });

            let existingGrammar = [];
            if (fs.existsSync(grammarSourcePath)) {
              try {
                existingGrammar = JSON.parse(fs.readFileSync(grammarSourcePath, 'utf8'));
              } catch (e) {
                console.log(`Could not parse ${grammarSourcePath}: ${e.message}`);
              }
            }

            let existingAnimeQuotes = [];
            if (fs.existsSync(animeQuotesSourcePath)) {
              try {
                existingAnimeQuotes = JSON.parse(fs.readFileSync(animeQuotesSourcePath, 'utf8'));
              } catch (e) {
                console.log(`Could not parse ${animeQuotesSourcePath}: ${e.message}`);
              }
            }

            let themesSourceContent = '';
            if (fs.existsSync(themesSourcePath)) {
              try {
                themesSourceContent = fs.readFileSync(themesSourcePath, 'utf8');
              } catch (e) {
                console.log(`Could not read ${themesSourcePath}: ${e.message}`);
              }
            }

            async function hasOpenIssueForQuery(query) {
              const q = `${query} repo:${context.repo.owner}/${context.repo.repo} is:issue is:open label:${templates.labels.community}`;
              try {
                const res = await github.rest.search.issuesAndPullRequests({
                  q: q,
                  per_page: 1
                });
                return res.data && res.data.total_count > 0;
              } catch (e) {
                console.log(`Search query failed: ${q} :: ${e.message}`);
                return false;
              }
            }

            const defaultOrder = ['theme', 'fact', 'proverb', 'trivia', 'grammar', 'animeQuote'];
            const typeOrder = forceType && defaultOrder.includes(forceType)
              ? [forceType]
              : defaultOrder;
            const currentIndex = typeOrder.indexOf(state.lastType);

            let item, issueTitle, issueBody;
            let selectedType = null;

            for (let offset = 1; offset <= typeOrder.length; offset += 1) {
              const nextType = typeOrder[((currentIndex === -1 ? -1 : currentIndex) + offset) % typeOrder.length];
              item = null;
              issueTitle = null;
              issueBody = null;

              if (nextType === 'theme') {
              // Skip items that are already issued OR completed OR already exist in main
              item = themes.find(function(th) {
                if (th.issued || th.completed) {
                  return false;
                }
                if (themesSourceContent) {
                  const hasId = th.id && themesSourceContent.includes("id: '" + th.id + "'");
                  const hasName = th.name && themesSourceContent.toLowerCase().includes(th.name.toLowerCase());
                  if (hasId || hasName) {
                    const themeIdx = themes.findIndex(function(ti) { return ti.id === th.id; });
                    themes[themeIdx].completed = true;
                    backlogChanged = true;
                    return false;
                  }
                }
                return true;
              });
              
              if (!item) {
                console.log('No more themes available in backlog.');
                if (backlogChanged) {
                  fs.writeFileSync(themeBacklogPath, JSON.stringify(themes, null, 2));
                }
                continue;
              }
              
              // Check for duplicate theme issue
              const duplicateTheme = await hasOpenIssueForQuery(`"Add New Color Theme:" "${item.name}"`);
              
              if (duplicateTheme) {
                console.log(`Issue already exists for theme "${item.name}": Marking as issued and skipping.`);
                const themeIdx = themes.findIndex(function(th) { return th.id === item.id; });
                themes[themeIdx].issued = true;
                fs.writeFileSync(themeBacklogPath, JSON.stringify(themes, null, 2));
                backlogChanged = true;

                continue;
              }
              
              const tmpl = t.theme;
              const common = t.common;
              issueTitle = tmpl.title
                .replace('{emoji}', pickEmoji())
                .replace('{name}', item.name);
              
              const instructions = t.buildInstructions(tmpl.file, tmpl.itemType, tmpl.prTitle, { step2: tmpl.step2, step3: tmpl.step3 }).map((instr, i) => `${i + 1}. ${instr.replace(/{name}/g, item.name)}`);
              
              const codeBlock = `\`\`\`typescript\n{\n  id: '${item.id}',\n  backgroundColor: '${item.backgroundColor}',\n  mainColor: '${item.mainColor}',\n  secondaryColor: '${item.secondaryColor}'\n},\n\`\`\``;
              
              issueBody = `${tmpl.header.replace('{name}', item.name)}\n\n**Category:** ${tmpl.category}  \n**Difficulty:** ${common.difficulty}  \n**Estimated Time:** ${tmpl.estimatedTime}\n\n---\n\n### üéØ Your Task\n\n${tmpl.taskDescription}\n\n${tmpl.detailsHeader}\n\n| Property | Value |\n|----------|-------|\n| **ID** | \`${item.id}\` |\n| **Background** | \`${item.backgroundColor}\` |\n| **Main Color** | \`${item.mainColor}\` |\n| **Secondary** | \`${item.secondaryColor}\` |\n\n> ${tmpl.vibeLabel} ${item.description}\n\n${common.instructionsHeader}\n\n${instructions[0]}\n${instructions[1]}\n${instructions[2]}\n\n${codeBlock}\n\n${instructions[3]}\n${instructions[4]}\n${instructions[5]}\n\n---\n\n${common.footer}`;
              
              const themeIndex = themes.findIndex(function(th) { return th.id === item.id; });
              themes[themeIndex].issued = true;
              fs.writeFileSync(themeBacklogPath, JSON.stringify(themes, null, 2));
              backlogChanged = true;
              
              } else if (nextType === 'fact') {
              // Skip items that are already issued OR completed OR already exist in main
              item = facts.find(function(f) {
                if (f.issued || f.completed) {
                  return false;
                }
                if (Array.isArray(existingFacts) && existingFacts.includes(f.fact)) {
                  const factIdx = facts.findIndex(function(fi) { return fi.id === f.id; });
                  facts[factIdx].completed = true;
                  backlogChanged = true;
                  return false;
                }
                return true;
              });
              
              if (!item) {
                console.log('No more facts available in backlog.');
                if (backlogChanged) {
                  fs.writeFileSync(themeBacklogPath, JSON.stringify(themes, null, 2));
                  fs.writeFileSync(factsBacklogPath, JSON.stringify(facts, null, 2));
                  fs.writeFileSync(proverbsBacklogPath, JSON.stringify(proverbs, null, 2));
                }
                continue;
              }
              
              // Check for duplicate fact issue
              const duplicateFact = await hasOpenIssueForQuery(`"Add Japan Fact #${item.id}"`);
              
              if (duplicateFact) {
                console.log(`Issue already exists for fact #${item.id}: Marking as issued and skipping.`);
                const factIdx = facts.findIndex(function(f) { return f.id === item.id; });
                facts[factIdx].issued = true;
                fs.writeFileSync(factsBacklogPath, JSON.stringify(facts, null, 2));
                backlogChanged = true;

                continue;
              }
              
              const tmpl = t.fact;
              const common = t.common;
              issueTitle = tmpl.title
                .replace('{emoji}', pickEmoji())
                .replace('{id}', item.id);
              
              const instructions = t.buildInstructions(tmpl.file, tmpl.itemType, tmpl.prTitle).map((instr, i) => `${i + 1}. ${instr.replace(/{id}/g, item.id)}`);
              
              issueBody = `${tmpl.header}\n\n**Category:** ${tmpl.category}  \n**Difficulty:** ${common.difficulty}  \n**Estimated Time:** ${tmpl.estimatedTime}\n\n---\n\n### üéØ Your Task\n\n${tmpl.taskDescription}\n\n${tmpl.factHeader}\n\n> ${item.fact}\n\n${common.instructionsHeader}\n\n${instructions.join('\n')}\n\n---\n\n${common.footer}`;
              
              const factIndex = facts.findIndex(function(f) { return f.id === item.id; });
              facts[factIndex].issued = true;
              fs.writeFileSync(factsBacklogPath, JSON.stringify(facts, null, 2));
              backlogChanged = true;
              } else if (nextType === 'proverb') {
              // Proverb
              item = proverbs.find(function(p) {
                if (p.issued || p.completed) {
                  return false;
                }
                if (Array.isArray(existingProverbs)) {
                  const exists = existingProverbs.some(function(ep) {
                    if (!ep || typeof ep !== 'object') {
                      return false;
                    }
                    return ep.japanese === p.japanese && ep.romaji === p.romaji && ep.english === p.english;
                  });
                  if (exists) {
                    const proverbIdx = proverbs.findIndex(function(pi) { return pi.id === p.id; });
                    proverbs[proverbIdx].completed = true;
                    backlogChanged = true;
                    return false;
                  }
                }
                return true;
              });
              
              if (!item) {
                console.log('No more proverbs available in backlog.');
                if (backlogChanged) {
                  fs.writeFileSync(themeBacklogPath, JSON.stringify(themes, null, 2));
                  fs.writeFileSync(factsBacklogPath, JSON.stringify(facts, null, 2));
                  fs.writeFileSync(proverbsBacklogPath, JSON.stringify(proverbs, null, 2));
                }
                continue;
              }
              
              // Check for duplicate proverb issue
              const duplicateProverb = await hasOpenIssueForQuery(`"Add Japanese Proverb #${item.id}"`);
              
              if (duplicateProverb) {
                console.log(`Issue already exists for proverb #${item.id}: Marking as issued and skipping.`);
                const proverbIdx = proverbs.findIndex(function(p) { return p.id === item.id; });
                proverbs[proverbIdx].issued = true;
                fs.writeFileSync(proverbsBacklogPath, JSON.stringify(proverbs, null, 2));
                backlogChanged = true;

                continue;
              }
              
              const tmpl = t.proverb;
              const common = t.common;
              issueTitle = tmpl.title
                .replace('{emoji}', pickEmoji())
                .replace('{id}', item.id);
              
              const instructions = t.buildInstructions(tmpl.file, tmpl.itemType, tmpl.prTitle).map((instr, i) => `${i + 1}. ${instr.replace(/{id}/g, item.id)}`);
              
              const codeBlock = `\`\`\`json\n{\n  "japanese": "${item.japanese}",\n  "romaji": "${item.romaji}",\n  "english": "${item.english}",\n  "meaning": "${item.meaning}"\n}\n\`\`\``;
              
              issueBody = `${tmpl.header}\n\n**Category:** ${tmpl.category}  \n**Difficulty:** ${common.difficulty}  \n**Estimated Time:** ${tmpl.estimatedTime}\n\n---\n\n### üéØ Your Task\n\n${tmpl.taskDescription}\n\n${tmpl.proverbHeader}\n\n| Japanese | Reading | English |\n|----------|---------|---------|\n| **${item.japanese}** | ${item.romaji} | ${item.english} |\n\n> üí° **Meaning:** ${item.meaning}\n\n${common.instructionsHeader}\n\n${instructions[0]}\n${instructions[1]}\n${instructions[2]}\n\n${codeBlock}\n\n${instructions[3]}\n${instructions[4]}\n${instructions[5]}\n\n---\n\n${common.footer}`;
              
              const proverbIndex = proverbs.findIndex(function(p) { return p.id === item.id; });
              proverbs[proverbIndex].issued = true;
              fs.writeFileSync(proverbsBacklogPath, JSON.stringify(proverbs, null, 2));
              backlogChanged = true;
              } else if (nextType === 'trivia') {
              item = trivia.find(function(q) {
                if (q.issued || q.completed) {
                  return false;
                }
                if (Array.isArray(existingTrivia)) {
                  const exists = existingTrivia.some(function(eq) {
                    if (!eq || typeof eq !== 'object') {
                      return false;
                    }
                    if (eq.question !== q.question) {
                      return false;
                    }
                    const eqAnswers = Array.isArray(eq.answers) ? eq.answers : [];
                    const qAnswers = Array.isArray(q.answers) ? q.answers : [];
                    return eqAnswers.length === qAnswers.length && eqAnswers.every(function(ans, idx) {
                      return ans === qAnswers[idx];
                    });
                  });
                  if (exists) {
                    const triviaIdx = trivia.findIndex(function(ti) { return ti.id === q.id; });
                    trivia[triviaIdx].completed = true;
                    backlogChanged = true;
                    return false;
                  }
                }
                return true;
              });

              if (!item) {
                console.log('No more trivia questions available in backlog.');
                if (backlogChanged) {
                  fs.writeFileSync(themeBacklogPath, JSON.stringify(themes, null, 2));
                  fs.writeFileSync(factsBacklogPath, JSON.stringify(facts, null, 2));
                  fs.writeFileSync(proverbsBacklogPath, JSON.stringify(proverbs, null, 2));
                  fs.writeFileSync(triviaBacklogPath, JSON.stringify(trivia, null, 2));
                  fs.writeFileSync(grammarBacklogPath, JSON.stringify(grammar, null, 2));
                }
                continue;
              }

              const duplicateTrivia = await hasOpenIssueForQuery(`"Add New Trivia Question #${item.id}"`);

              if (duplicateTrivia) {
                console.log(`Issue already exists for trivia #${item.id}: Marking as issued and skipping.`);
                const triviaIdx = trivia.findIndex(function(q) { return q.id === item.id; });
                trivia[triviaIdx].issued = true;
                fs.writeFileSync(triviaBacklogPath, JSON.stringify(trivia, null, 2));
                backlogChanged = true;
                continue;
              }

              const tmpl = t.trivia;
              const common = t.common;
              issueTitle = tmpl.title
                .replace('{emoji}', pickEmoji())
                .replace('{id}', item.id);

              const difficultyFile = triviaSourcePaths[item.difficulty] || triviaSourcePaths.easy;
              const instructions = t.buildInstructions(tmpl.file.replace('{difficultyFile}', difficultyFile), tmpl.itemType, tmpl.prTitle).map((instr, i) => `${i + 1}. ${instr.replace(/{id}/g, item.id)}`);
              const answers = Array.isArray(item.answers) ? item.answers : [];
              const codeBlock = `\`\`\`json\n{\n  "question": "${item.question}",\n  "difficulty": "${item.difficulty}",\n  "answers": [\n    "${answers.join('\",\n    \"')}"\n  ],\n  "correctIndex": ${item.correctIndex}\n}\n\`\`\``;

              issueBody = `${tmpl.header}\n\n**Category:** ${tmpl.category}  \n**Difficulty:** ${common.difficulty}  \n**Estimated Time:** ${tmpl.estimatedTime}\n\n---\n\n### üéØ Your Task\n\n${tmpl.taskDescription}\n\n${tmpl.triviaHeader}\n\n**Question:** ${item.question}\n\n**Answers:**\n${answers.map(function(a, idx) { return `${idx + 1}. ${a}`; }).join('\n')}\n\n**Correct Answer Index:** ${item.correctIndex}\n\n${common.instructionsHeader}\n\n${instructions[0]}\n${instructions[1]}\n${instructions[2]}\n\n${codeBlock}\n\n${instructions[3]}\n${instructions[4]}\n${instructions[5]}\n\n---\n\n${common.footer}`;

              const triviaIndex = trivia.findIndex(function(q) { return q.id === item.id; });
              trivia[triviaIndex].issued = true;
              fs.writeFileSync(triviaBacklogPath, JSON.stringify(trivia, null, 2));
              backlogChanged = true;
              } else if (nextType === 'grammar') {
              // Grammar
              item = grammar.find(function(g) {
                if (g.issued || g.completed) {
                  return false;
                }
                if (Array.isArray(existingGrammar) && existingGrammar.includes(g.text)) {
                  const grammarIdx = grammar.findIndex(function(gi) { return gi.id === g.id; });
                  grammar[grammarIdx].completed = true;
                  backlogChanged = true;
                  return false;
                }
                return true;
              });

              if (!item) {
                console.log('No more grammar points available in backlog.');
                if (backlogChanged) {
                  fs.writeFileSync(themeBacklogPath, JSON.stringify(themes, null, 2));
                  fs.writeFileSync(factsBacklogPath, JSON.stringify(facts, null, 2));
                  fs.writeFileSync(proverbsBacklogPath, JSON.stringify(proverbs, null, 2));
                  fs.writeFileSync(triviaBacklogPath, JSON.stringify(trivia, null, 2));
                  fs.writeFileSync(grammarBacklogPath, JSON.stringify(grammar, null, 2));
                }
                continue;
              }

              const duplicateGrammar = await hasOpenIssueForQuery(`"Add New Grammar Point #${item.id}"`);

              if (duplicateGrammar) {
                console.log(`Issue already exists for grammar #${item.id}: Marking as issued and skipping.`);
                const grammarIdx = grammar.findIndex(function(g) { return g.id === item.id; });
                grammar[grammarIdx].issued = true;
                fs.writeFileSync(grammarBacklogPath, JSON.stringify(grammar, null, 2));
                backlogChanged = true;
                continue;
              }

              const tmpl = t.grammar;
              const common = t.common;
              issueTitle = tmpl.title
                .replace('{emoji}', pickEmoji())
                .replace('{id}', item.id);

              const instructions = t.buildInstructions(tmpl.file, tmpl.itemType, tmpl.prTitle).map((instr, i) => `${i + 1}. ${instr.replace(/{id}/g, item.id)}`);
              const codeBlock = `\`\`\`json\n"${item.text}"\n\`\`\``;

              issueBody = `${tmpl.header}\n\n**Category:** ${tmpl.category}  \n**Difficulty:** ${common.difficulty}  \n**Estimated Time:** ${tmpl.estimatedTime}\n\n---\n\n### üéØ Your Task\n\n${tmpl.taskDescription}\n\n${tmpl.grammarHeader}\n\n> ${item.text}\n\n${common.instructionsHeader}\n\n${instructions[0]}\n${instructions[1]}\n${instructions[2]}\n\n${codeBlock}\n\n${instructions[3]}\n${instructions[4]}\n${instructions[5]}\n\n---\n\n${common.footer}`;

              const grammarIndex = grammar.findIndex(function(g) { return g.id === item.id; });
              grammar[grammarIndex].issued = true;
              fs.writeFileSync(grammarBacklogPath, JSON.stringify(grammar, null, 2));
              backlogChanged = true;
              } else {
              // Anime Quote
              item = animeQuotes.find(function(q) {
                if (q.issued || q.completed) {
                  return false;
                }
                if (Array.isArray(existingAnimeQuotes)) {
                  const exists = existingAnimeQuotes.some(function(eq) {
                    if (!eq || typeof eq !== 'object') {
                      return false;
                    }
                    return eq.japanese === q.japanese
                      && eq.romaji === q.romaji
                      && eq.english === q.english
                      && eq.anime === q.anime
                      && eq.character === q.character;
                  });
                  if (exists) {
                    const quoteIdx = animeQuotes.findIndex(function(qi) { return qi.id === q.id; });
                    animeQuotes[quoteIdx].completed = true;
                    backlogChanged = true;
                    return false;
                  }
                }
                return true;
              });

              if (!item) {
                console.log('No more anime quotes available in backlog.');
                if (backlogChanged) {
                  fs.writeFileSync(themeBacklogPath, JSON.stringify(themes, null, 2));
                  fs.writeFileSync(factsBacklogPath, JSON.stringify(facts, null, 2));
                  fs.writeFileSync(proverbsBacklogPath, JSON.stringify(proverbs, null, 2));
                  fs.writeFileSync(triviaBacklogPath, JSON.stringify(trivia, null, 2));
                  fs.writeFileSync(grammarBacklogPath, JSON.stringify(grammar, null, 2));
                  fs.writeFileSync(animeQuotesBacklogPath, JSON.stringify(animeQuotes, null, 2));
                }
                continue;
              }

              const duplicateQuote = await hasOpenIssueForQuery(`"Add Famous Anime Quote #${item.id}"`);

              if (duplicateQuote) {
                console.log(`Issue already exists for anime quote #${item.id}: Marking as issued and skipping.`);
                const quoteIdx = animeQuotes.findIndex(function(q) { return q.id === item.id; });
                animeQuotes[quoteIdx].issued = true;
                fs.writeFileSync(animeQuotesBacklogPath, JSON.stringify(animeQuotes, null, 2));
                backlogChanged = true;
                continue;
              }

              const tmpl = t.animeQuote;
              const common = t.common;
              issueTitle = tmpl.title
                .replace('{emoji}', pickEmoji())
                .replace('{id}', item.id);

              const instructions = t.buildInstructions(tmpl.file, tmpl.itemType, tmpl.prTitle).map((instr, i) => `${i + 1}. ${instr.replace(/{id}/g, item.id)}`);
              const codeBlock = `\`\`\`json\n{\n  \"japanese\": \"${item.japanese}\",\n  \"romaji\": \"${item.romaji}\",\n  \"english\": \"${item.english}\",\n  \"anime\": \"${item.anime}\",\n  \"character\": \"${item.character}\"\n}\n\`\`\``;

              issueBody = `${tmpl.header}\n\n**Category:** ${tmpl.category}  \n**Difficulty:** ${common.difficulty}  \n**Estimated Time:** ${tmpl.estimatedTime}\n\n---\n\n### üéØ Your Task\n\n${tmpl.taskDescription}\n\n${tmpl.quoteHeader}\n\n| Japanese | Romaji | English |\n|----------|--------|---------|\n| **${item.japanese}** | ${item.romaji} | ${item.english} |\n\n**Anime:** ${item.anime}  \n**Character:** ${item.character}\n\n${common.instructionsHeader}\n\n${instructions[0]}\n${instructions[1]}\n${instructions[2]}\n\n${codeBlock}\n\n${instructions[3]}\n${instructions[4]}\n${instructions[5]}\n\n---\n\n${common.footer}`;

              const quoteIndex = animeQuotes.findIndex(function(q) { return q.id === item.id; });
              animeQuotes[quoteIndex].issued = true;
              fs.writeFileSync(animeQuotesBacklogPath, JSON.stringify(animeQuotes, null, 2));
              backlogChanged = true;
            }

              if (issueTitle && issueBody && item) {
                selectedType = nextType;
                break;
              }
            }

            if (!selectedType) {
              console.log('No available items found across theme/fact/proverb backlogs.');
              state.lastRun = new Date().toISOString();
              state.consecutiveNoIssueRuns = (state.consecutiveNoIssueRuns || 0) + 1;
              fs.writeFileSync(statePath, JSON.stringify(state, null, 2));

              core.setOutput('issue_created', 'false');
              core.setOutput('reason', 'no_available_items');
              core.setOutput('consecutive_no_issue_runs', String(state.consecutiveNoIssueRuns));
              core.setOutput('should_commit', backlogChanged ? 'true' : 'false');
              core.setOutput('notify_discord', state.consecutiveNoIssueRuns >= 8 ? 'true' : 'false');
              return;
            }

            if (dryRun) {
              console.log(`Dry run enabled; would create a ${selectedType} issue: ${issueTitle}`);

              state.lastType = selectedType;
              state.lastRun = new Date().toISOString();
              state.consecutiveNoIssueRuns = 0;
              fs.writeFileSync(statePath, JSON.stringify(state, null, 2));

              core.setOutput('issue_created', 'false');
              core.setOutput('reason', 'dry_run');
              core.setOutput('selected_type', selectedType);
              core.setOutput('should_commit', backlogChanged ? 'true' : 'false');
              core.setOutput('notify_discord', 'false');
              return;
            }

            const labels = templates.labels.newIssue;

            const response = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: issueTitle,
              body: issueBody,
              labels: labels,
              type: 'Task'
            });

            console.log(`Created issue #${response.data.number}: ${issueTitle}`);

            state.lastType = selectedType;
            state.lastRun = new Date().toISOString();
            state.totalIssuesCreated = (state.totalIssuesCreated || 0) + 1;
            state.lastIssueCreatedAt = new Date().toISOString();
            state.consecutiveNoIssueRuns = 0;
            fs.writeFileSync(statePath, JSON.stringify(state, null, 2));

            core.setOutput('issue_number', response.data.number);
            core.setOutput('issue_type', selectedType);
            core.setOutput('item_id', item.id);
            core.setOutput('issue_created', 'true');
            core.setOutput('reason', 'created');
            core.setOutput('consecutive_no_issue_runs', String(state.consecutiveNoIssueRuns));
            core.setOutput('should_commit', 'true');
            core.setOutput('notify_discord', 'false');

      - name: Commit backlog updates
        id: commit-backlog
        if: steps.create-issue.outputs.should_commit == 'true' && env.AUTOMATION_PR_TOKEN != ''
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.AUTOMATION_PR_TOKEN }}
          add-paths: |
            data/community/
          commit-message: 'chore(automation): mark item as issued'
          branch: automation/community-data/hourly-${{ github.run_id }}
          title: 'chore(automation): update community backlog'
          body: Automated update to community backlog state.
          base: main
          delete-branch: true

      - name: Auto-approve and merge automation PR
        if: steps.create-issue.outputs.should_commit == 'true' && env.AUTOMATION_PR_TOKEN != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AUTOMATION_PR_TOKEN }}
          script: |
            const prNumber = Number(process.env.PR_NUMBER);

            async function sleep(ms) {
              return new Promise(function(resolve) { setTimeout(resolve, ms); });
            }

            if (!prNumber) {
              console.log('No PR was created; nothing to merge');
              return;
            }

            const MAX_RETRIES = 10;
            for (let i = 1; i <= MAX_RETRIES; i += 1) {
              try {
                await github.rest.pulls.merge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  merge_method: 'squash'
                });
                console.log(`Merged automation PR #${prNumber}`);

                try {
                  const { data: pr } = await github.rest.pulls.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: prNumber
                  });
                  const ref = pr && pr.head && pr.head.ref;
                  if (ref) {
                    await github.rest.git.deleteRef({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      ref: `heads/${ref}`
                    });
                    console.log(`Deleted automation branch: ${ref}`);
                  }
                } catch (deleteErr) {
                  console.log(`Could not delete automation branch: ${deleteErr.message}`);
                }
                return;
              } catch (e) {
                console.log(`Merge attempt ${i} failed: ${e.message}`);
                if (e.status === 409) {
                  try {
                    await github.rest.pulls.updateBranch({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: prNumber
                    });
                    console.log(`Requested branch update for PR #${prNumber}`);
                  } catch (updateErr) {
                    console.log(`Could not update branch: ${updateErr.message}`);
                  }
                }
                if (i < MAX_RETRIES) {
                  await sleep(2000);
                }
              }
            }

            throw new Error(`Failed to merge automation PR #${prNumber}`);
        env:
          PR_NUMBER: ${{ steps.commit-backlog.outputs.pull-request-number }}

      - name: Notify Discord if no issues are being created
        if: steps.create-issue.outputs.notify_discord == 'true'
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_URL || secrets.DISCORD_WEBHOOK }}
          REPO: ${{ github.repository }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          COUNT: ${{ steps.create-issue.outputs.consecutive_no_issue_runs }}
        run: |
          if [ -z "$DISCORD_WEBHOOK" ]; then
            echo "No Discord webhook configured; skipping"
            exit 0
          fi
          python3 << 'PY' > /tmp/payload.json
          import json
          import os

          repo = os.environ.get('REPO', 'unknown')
          run_url = os.environ.get('RUN_URL', '')
          count = os.environ.get('COUNT', 'unknown')

          payload = {
            "content": f"‚ö†Ô∏è Community issue creation has not created any issues for {count} consecutive runs in `{repo}`.\n{run_url}" 
          }
          print(json.dumps(payload))
          PY
          curl -sf -H "Content-Type: application/json" -X POST -d @/tmp/payload.json "$DISCORD_WEBHOOK"
